from nltk import word_tokenize as tokenize
from clyngor import solve
from ASP_PE import ASP_PE

colors={'gray', 'red', 'blue', 'green', 'brown', 'cyan', 'purple', 'yellow'}
shapes={'cube', 'sphere', 'cylinder'}
materials={'metal', 'rubber'}



PE_rules='''
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rules as interface to turn the above atoms into more general forms
%   * New atoms:
%      counterfact(remove, qobj(I))
%      option(OptionIdx, qobj(I1), Event, qobj(I2))
%      feature(qobj(I), Feature)
%      query(negated)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
counterfact(remove, qobj(0)).
option(C, qobj(C*10 + 1), collide, qobj(C*10 + 2)) :- choice(C,_,_).

feature(qobj(0), Feature) :- question(_,Feature).
feature(qobj(C*10 + I), Feature) :- choice(C, I, Feature).

query(negated) :- question(no,_).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Supress warnings of "atom does not occur in any rule head"
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#defined size/2.
#defined enter/3.
#defined query/3.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helper atoms
%   * turn size/2, color/2, shape/2 into feature/3 and feature/2
%   * pos_result/1 denotes the possible result in {yes, no}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


feature(O, size, V) :- size(O, V).
feature(O, color, V) :- color(O, V).
feature(O, shape, V) :- shape(O, V).
feature(O, material, V) :- material(O, V).

feature(O, V) :- feature(O, _, V).

pos_result(yes; no).

% Each object in query should be the same as an object in video

same(qobj(I), O) :- feature(O,_,_), feature(qobj(I),_), feature(O,_,F): feature(qobj(I),F).

% Define removed object(s)

removed(O) :- counterfact(remove, qobj(I)), same(qobj(I), O).

collision(O2,O1,F) :- collision(O1,O2,F).
%answer from simulator

% if the option collision matches with any of the cfSim/2 facts such that the collision is in the set generated by the simulator, then the answer is yes (or no if the question contains a negation).
answer(Idx, Ans) :- collision(O1,O2,F), F>125, option(Idx,qobj(I1), collide, qobj(I2)), same(qobj(I1), O1),same(qobj(I2), O2), pos_result(Ans), Ans=yes:not query(negated); Ans=no: query(negated).
answer(Idx, Ans):- not answer(Idx, Ans2), option(Idx,_,_,_), pos_result(Ans), pos_result(Ans2), Ans!=Ans2, Ans=no : not query(negated); Ans=yes: query(negated).
#show answer/2.

'''


def filter_moving(sim, objs, frame):
    """
    Filter all moving objects in the input list
    - args: sim(simulation object), objects(list), frame(int)
    - return: objects(list)
    """
    if type(objs) is not list:
        return 'error'
    if type(frame) is not int and frame != 'null':
        return 'error'
    if frame == 'null':
        frame = None
    output_objs = []
    for o in objs:
        if sim.is_visible(o, frame_idx=frame) and \
           sim.is_moving(o, frame_idx=frame):
            output_objs.append(o)
    return output_objs

def filter_stationary(sim, objs, frame):
    """
    Filter all moving objects in the input list
    - args: sim(simulation object), objects(list), frame(int)
    - return: objects(list)
    """
    if type(objs) is not list:
        return 'error'
    if type(frame) is not int and frame != 'null':
        return 'error'
    if frame == 'null':
        frame = None
    output_objs = []
    for o in objs:
        if sim.is_visible(o, frame_idx=frame) and \
           not sim.is_moving(o, frame_idx=frame):
            output_objs.append(o)
    return output_objs

def _events(sim):
    """
    Return full event list sorted in time order
    - args: sim(simulation object)
    - return: events(list)
    """
    events = _get_events(sim)[:]
    events = sorted(events, key=lambda k: k['frame'])
    return events


def _convert_event_idx_cf2gt(sim, event, drop_idx):
    event_objs_converted = []
    for o in event['object']:
        if o >= drop_idx:
            event_objs_converted.append(o+1)
        else:
            event_objs_converted.append(o)
    event['object'] = event_objs_converted
    return event

def _get_events(sim, drop_idx=None):
    events = [
        {
            'type': 'start',
            'frame': 0,
        },
        {
            'type': 'end',
            'frame': 125,
        },
    ]
    for io in sim.in_out:
        if io['frame'] < sim.n_vis_frames:
            io_event = {
                'type': io['type'],
                'object': io['object'],
                'frame': io['frame'],
            }
            if drop_idx is not None:
                io_event = _convert_event_idx_cf2gt(io_event, drop_idx)
            events.append(io_event)
    for c in sim.collisions:
        if c['frame'] < sim.n_vis_frames:
            col_event = {
                'type': 'collision',
                'object': c['object'],
                'frame': c['frame']
            }
            if drop_idx is not None:
                col_event = _convert_event_idx_cf2gt(col_event, drop_idx)
            events.append(col_event)
    return events




def _get_unseen_events(sim):
    """Return a list of events (time_indicators) of events that are 
    going to happen
    """
    unseen_events = []
    for io in sim.in_out:
        if io['frame'] >= sim.n_vis_frames:
            io_event = {
                'type': io['type'],
                'object': [io['object']],
                'frame': io['frame'],
            }
            unseen_events.append(io_event)
    for c in sim.collisions:
        if c['frame'] >= sim.n_vis_frames:
            col_event = {
                'type': 'collision',
                'object': c['object'],
                'frame': c['frame'],
            }
            unseen_events.append(col_event)
    return unseen_events

def write_n_run(sim, question,choices, args, ASP_CR):
    """
    Return answer set facts corresponding to answer/2 and sim/2
    - args:
    - return: answer_facts(dict), sims(dict)
    """
    obj_attributes,moving,stationary,events,unseen_events, cf_events =get_base_facts(sim,args)
    ASP_facts=get_base_ASP(obj_attributes,moving,stationary,events,unseen_events, cf_events,ASP_CR)
    
    partial_ASP_program=create_ASP_query(question,choices,ASP_CR)
    default_program=ASP_facts + partial_ASP_program
    temp_ASP=open('temp_ASP.lp','w')
    temp_ASP.write(default_program)
    temp_ASP.close()
    clingo_solved=solve('temp_ASP.lp', options='--warn none')
    all_lines=[]
    for line in clingo_solved:
        all_lines.append(line)

    answer_facts=[fact for fact in list(all_lines[0]) if 'answer' == fact[0]]
    answer_facts=[(int(str(ans[1][0])[-1]),ans[1][1]) for ans in answer_facts]
    answer_facts={item[0]:item[1] for item in answer_facts}
    
    
# =============================================================================
#     answerNoSim_facts=[fact for fact in list(all_lines[0]) if 'answerNoSim' == fact[0]]
#     answerNoSim_facts=[(int(str(ans[1][0])[-1]),ans[1][1]) for ans in answerNoSim_facts]
#     answerNoSim_facts={item[0]:item[1] for item in answerNoSim_facts}
#     
#     
#     answerSim_facts=[fact for fact in list(all_lines[0]) if 'answerSim' == fact[0]]
#     answerSim_facts=[(int(str(ans[1][0])[-1]),ans[1][1]) for ans in answerSim_facts]
#     answerSim_facts={item[0]:item[1] for item in answerSim_facts}
# =============================================================================
    
    
    sims=[fact for fact in list(all_lines[0]) if 'sim' in fact]
    sims=[(sim[1][0],sim[1][1]) for sim in sims]
    sims={sim[0]:sim[1] for sim in sims}


    return answer_facts,sims


def write_n_run_PE(sim, question,choices, args):
    """
    Return answer set facts corresponding to answer/2 and sim/2
    - args:
    - return: answer_facts(dict), sims(dict)
    """
    obj_attributes,moving,stationary,events,unseen_events, cf_events =get_base_facts(sim,args)
    ASP_facts=get_base_ASP(obj_attributes,moving,stationary,events,unseen_events, cf_events,False)
    
    partial_ASP_program=create_ASP_query(question,choices,args.ASP_CR)
    default_program=ASP_facts + partial_ASP_program
    temp_ASP=open('temp_ASP.lp','w')
    temp_ASP.write(default_program)
    temp_ASP.close()
    clingo_solved=solve('temp_ASP.lp', options='--warn none')
    all_lines=[]
    for line in clingo_solved:
        all_lines.append(line)

    answer_facts=[fact for fact in list(all_lines[0]) if 'answer' == fact[0]]
    answer_facts=[(int(str(ans[1][0])[-1]),ans[1][1]) for ans in answer_facts]
    answer_facts={item[0]:item[1] for item in answer_facts}
    
    
# =============================================================================
#     answerNoSim_facts=[fact for fact in list(all_lines[0]) if 'answerNoSim' == fact[0]]
#     answerNoSim_facts=[(int(str(ans[1][0])[-1]),ans[1][1]) for ans in answerNoSim_facts]
#     answerNoSim_facts={item[0]:item[1] for item in answerNoSim_facts}
#     
#     
#     answerSim_facts=[fact for fact in list(all_lines[0]) if 'answerSim' == fact[0]]
#     answerSim_facts=[(int(str(ans[1][0])[-1]),ans[1][1]) for ans in answerSim_facts]
#     answerSim_facts={item[0]:item[1] for item in answerSim_facts}
# =============================================================================
    
    
    sims=[fact for fact in list(all_lines[0]) if 'sim' in fact]
    sims=[(sim[1][0],sim[1][1]) for sim in sims]
    sims={sim[0]:sim[1] for sim in sims}


    return answer_facts,sims





def get_question_string(q):
    """
    Return facts for ASP program
    - args: q(string)
    - return: obj1_string(string), negate_string(string)
    """
    split_words=tokenize(q)
    negate='not' in split_words
    negate_string='no' if negate else 'yes'
    objq_string=''
    #breakpoint()
    for word in split_words:
        if word in colors:
            string='question({0},{1}).'.format(negate_string,word)
        elif word in shapes:
            string='question({0},{1}).'.format(negate_string,word)
        elif word in materials:
            string='question({0},{1}).'.format(negate_string,word)
        else:
            continue
        objq_string+=string 
    objq_string+='\n'
    return objq_string,negate_string


def get_choice_strings(c,choice_num):
    """
    Return facts for ASP program
    - args: c(string), choice_num(int)
    - return: choice string for ASP program
    """
    if 'with' in c:
        split1,split2=c.split('with')
    elif 'and' in c:
        split1,split2=c.split('and')

    split1_words=tokenize(split1)
    split2_words=tokenize(split2)

    obj1_string=''
    for word in split1_words:
        if word in colors:
            string='choice({0}, 1, {1}).'.format(choice_num,word)
        elif word in shapes:
            string='choice({0}, 1, {1}).'.format(choice_num,word)
        elif word in materials:
            string='choice({0}, 1, {1}).'.format(choice_num,word)
        else:
            continue
        obj1_string+=string

    obj2_string=''
    for word in split2_words:
        if word in colors:
            string='choice({0}, 2, {1}).'.format(choice_num,word)
        elif word in shapes:
            string='choice({0}, 2, {1}).'.format(choice_num,word)
        elif word in materials:
            string='choice({0}, 2, {1}).'.format(choice_num,word)
        else:
            continue
        obj2_string+=string


    return obj1_string+'\n'+ obj2_string


def create_ASP_query(question,choices,ASP_CR):

    """
    Return facts for ASP program
    - args: question(str), program(str)
    - return: complete ASP program
    """

    rules = ASP_PE

    question_string,negate_string=get_question_string(question)
    choices_string=''
    for c_idx, choice in enumerate(choices):
        choice_string=get_choice_strings(choice,c_idx)    
        choices_string+=choice_string+'\n\n'
    
    initial_lp_partial=question_string + '\n' + choices_string
    causal_lp = rules + '\n' 
    return initial_lp_partial + causal_lp + "#show answer/2. "


def get_base_ASP(obj_attributes,moving,stationary,events,unseen_events, cf_events, ASP_CR):
    """
    Returns ASP facts
    - args: obj_attributes,moving(list),stationary(list),events(list),unseen_events(list)
    - return: partial input.lp string
    """
    # =============================================================================
    # Object Attributes
    # =============================================================================

    attributes_string=''
    for obj_idx,obj in enumerate(obj_attributes):

        attrs=[]
        for key in obj:
            attrs.append(obj[key])
        attributes_string+='color({0},{1}). material({0},{2}). shape({0},{3}).\n'.format(obj_idx,*attrs)


    # =============================================================================
    # Moving
    # =============================================================================
    moving_string=''

    for frame_idx,move in enumerate(moving):
        line=''
        for obj in move:
            line+='moving({0},{1}).'.format(obj,frame_idx*1)
        if line:
            moving_string+=line +'\n'


    # =============================================================================
    # Stationary
    # =============================================================================

    stationary_string=''

    for frame_idx,move in enumerate(stationary):
        line=''
        for obj in move:
            line+='stationary({0},{1}).'.format(obj,frame_idx*1)
        if line:
            stationary_string+=line+'\n'

    # =============================================================================
    #     Events
    # =============================================================================

    events_string=''

    for event in events:
        if event['type']=='in':
            pass
            #events_string+='enter({0},{1}). \n'.format(event['object'][0],event['frame'])
        elif event['type']=='collision':
            events_string+='collision({0},{1},{2}). \n'.format(event['object'][0],event['object'][1],event['frame'])


# =============================================================================
#     Unseen Events
# =============================================================================

    unseen_events_string=''
    for event in unseen_events:
        if event['type']=='in':
            unseen_events_string+='enter({0},{1}). \n'.format(event['object'][0],event['frame'])
        elif event['type']=='collision':
            unseen_events_string+='collision({0},{1},{2}). \n'.format(event['object'][0],event['object'][1],event['frame'])

# =============================================================================
#     counterfactual events
# =============================================================================
    cf_events_string = ''
    for obj_removed, events in cf_events.items():
        
        for event in events:
            if event['type']=='collision':
                obj1,obj2=event['object']
                frame = event['frame']
            cf_events_string+=f'cfSim({obj_removed}, collision({obj1},{obj2},{frame})).\n'
    
    
    if ASP_CR:
        final_string=attributes_string +  '\n\n' +events_string+ '\n' + unseen_events_string + '\n\n' + cf_events_string 
    else:
        final_string=attributes_string + '\n\n' + unseen_events_string 

    return final_string



def get_base_facts(sim,args):
    """
    Return base facts of the scene
    - args: sim(simulation object), args
    - return: base facts from scene
    """
    num_of_objects=len(sim.get_visible_objs())
    obj_attributes=[]
    for i in range(num_of_objects):
        obj_attributes.append(sim.get_static_attrs(i))

    frame_range=range(0,128) if args.IOD else range(0,125,5)

    moving=[];stationary=[]
    for frame_num in frame_range:
        moving.append(filter_moving(sim, [i for i in range(num_of_objects)],frame_num))
        stationary.append(filter_stationary(sim, [i for i in range(num_of_objects)],frame_num))
    events=_events(sim)
    unseen_events=_get_unseen_events(sim)
    
    return obj_attributes, moving,stationary,events,unseen_events, sim.cf_events

